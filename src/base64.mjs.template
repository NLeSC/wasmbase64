const decodeWasmCode = new Uint8Array([${decode_uint8}]);
let decodeWasmModule = null;

const encodeWasmCodeBase64 = "${encode_base64}";
let encodeWasmCode = null;
let encodeWasmModule = null;

const PAGE_SIZE = 1024 * 64;

export class Base64Decoder {
    constructor() {
      this.instance = null;
    };

    decodedLength(input) {
        let pad = 0 ;
        const inputSize = input.byteLength;
        const inputUint8 = new Uint8Array(input);
        if( inputSize < 2 ) { // 2 accesses below would be OOB.
            return 0;
        }
        // String.fromCharCode(61) === "="
        if( inputUint8[ inputSize-1 ] === 61 ) ++pad ;
        if( inputUint8[ inputSize-2 ] === 61 ) ++pad ;
        return 3*inputSize/4 - pad;
    }

    async init () {
        if (!decodeWasmModule) {
            decodeWasmModule = await WebAssembly.compile(decodeWasmCode);
        }
        if (!this.instance) {
            this.instance = await WebAssembly.instantiate(decodeWasmModule, { });
        }
    }

    decode (inputBuffer) {
        if (!this.instance) { throw new Error("Please call .init() first."); }
        const heapBase = this.instance.exports.__heap_base.value
        const decodedLength = this.decodedLength(inputBuffer);

        // ensure there is enough memory
        const requiredMemory = heapBase + inputBuffer.byteLength + decodedLength;
        const requiredPages = Math.ceil(requiredMemory / PAGE_SIZE);
        const currentPages = this.instance.exports.memory.buffer.byteLength / PAGE_SIZE;
        if (requiredPages > currentPages) {
            this.instance.exports.memory.grow(requiredPages - currentPages);
        }

        const membuf = new Uint8Array(this.instance.exports.memory.buffer, heapBase);

        membuf.set(inputBuffer);
        this.instance.exports.unbase64(heapBase, inputBuffer.byteLength);
        return membuf.slice(inputBuffer.byteLength, inputBuffer.byteLength + decodedLength);
    }

    decodeString (inputString) {
        const textEncoder = new TextEncoder('utf-8');
        const textDecoder = new TextDecoder('utf-8');
        return this.decode(
            textEncoder.encode(inputString)
        );
    }
}

export class Base64Encoder {
    constructor() {
      this.instance = null;
    };

    encodedLength(inputLength) {
        const modulusLen = inputLength % 3 ;
        const pad = ((modulusLen&1)<<1) + ((modulusLen&2)>>1);
        const encLength = 4*(inputLength + pad)/3 ;
        return encLength;
    }

    async init () {
        if (!encodeWasmCode) {
            const decoder = new Base64Decoder();
            await decoder.init();
            encodeWasmCode = decoder.decodeString(encodeWasmCodeBase64);
        }
        if (!encodeWasmModule) {
            encodeWasmModule = await WebAssembly.compile(encodeWasmCode);
        }
        if (!this.instance) {
            this.instance = await WebAssembly.instantiate(encodeWasmModule, { });
        }
    }

    encode (inputBuffer) {
        if (!this.instance) { throw new Error("Please call .init() first."); }
        const heapBase = this.instance.exports.__heap_base.value
        const encodedLength = this.encodedLength(inputBuffer.byteLength);

        // ensure there is enough memory
        const requiredMemory = heapBase + inputBuffer.byteLength + encodedLength;
        const requiredPages = Math.ceil(requiredMemory / PAGE_SIZE);
        const currentPages = this.instance.exports.memory.buffer.byteLength / PAGE_SIZE;
        if (requiredPages > currentPages) {
            this.instance.exports.memory.grow(requiredPages - currentPages);
        }

        const membuf = new Uint8Array(this.instance.exports.memory.buffer, heapBase);

        membuf.set(inputBuffer);
        this.instance.exports.base64(heapBase, inputBuffer.byteLength);
        return membuf.slice(inputBuffer.byteLength, inputBuffer.byteLength + encodedLength);
    }

    encodeString (inputString) {
        const textEncoder = new TextEncoder('utf-8');
        return this.encode(
            textEncoder.encode(inputString)
        );
    }
}
